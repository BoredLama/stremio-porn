{"version":3,"sources":["../src/PornClient.js"],"names":["ID","CACHE_PREFIX","ADAPTERS","PornHub","RedTube","YouPorn","SpankWire","PornCom","Chaturbate","CATALOGS","map","name","DISPLAY_NAME","SUPPORTED_TYPES","GENRES","type","id","makePornId","genres","extra","reduce","a","b","concat","adapter","parsePornId","pornId","split","pop","normalizeResult","item","newItem","constructor","PornClient","options","httpClient","HttpClient","adapters","Adapter","cache","cacheManager","caching","store","redisStore","url","_getAdapterForRequest","adapterName","matchingAdapters","filter","includes","_invokeAdapterMethod","method","request","console","log","results","result","_retrieveResource","resourceName","args","query","isNaN","skip","parseInt","search","genre","adapterImpl","Error","metas","meta","streams","invokeResource","cacheTtl","cacheKey","JSON","stringify","cacheOptions","ttl","wrap"],"mappings":"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","sourcesContent":["import cacheManager from 'cache-manager'\nimport redisStore from 'cache-manager-redis-store'\nimport HttpClient from './HttpClient'\nimport PornHub from './adapters/PornHub'\nimport RedTube from './adapters/RedTube'\nimport YouPorn from './adapters/YouPorn'\nimport SpankWire from './adapters/SpankWire'\nimport PornCom from './adapters/PornCom'\nimport Chaturbate from './adapters/Chaturbate'\n\n// EPorner has restricted video downloads to 30 per day per guest\n// import EPorner from './adapters/EPorner'\n\nconst ID = 'porn_id'\nconst CACHE_PREFIX = 'stremio-porn|'\n// Making multiple requests to multiple adapters for different types\n// and then aggregating them is a lot of work,\n// so we only support 1 adapter per request for now.\nconst ADAPTERS = [PornHub, RedTube, YouPorn, SpankWire, PornCom, Chaturbate]\nconst CATALOGS = ADAPTERS.map(({ name, DISPLAY_NAME, SUPPORTED_TYPES, GENRES }) => {\n  return SUPPORTED_TYPES.map((type) => ({\n    type,\n    id: makePornId(name, type, 'top'),\n    name: `Porn: ${DISPLAY_NAME}`,\n    genres: GENRES,\n    extra: [{ name: 'search' }, { name: 'genre' }],\n  }))\n}).reduce((a, b) => a.concat(b), [])\n\nfunction makePornId(adapter, type, id) {\n  return `${ID}:${adapter}-${type}-${id}`\n}\n\nfunction parsePornId(pornId) {\n  let [adapter, type, id] = pornId.split(':').pop().split('-')\n  return { adapter, type, id }\n}\n\nfunction normalizeResult(adapter, item) {\n  let newItem = { ...item }\n  if (item.id) {\n    newItem.id = makePornId(adapter.constructor.name, item.type, item.id)\n  }\n  return newItem\n}\n\nclass PornClient {\n  static ID = ID\n  static ADAPTERS = ADAPTERS\n  static CATALOGS = CATALOGS\n\n  constructor(options) {\n    let httpClient = new HttpClient(options)\n    this.adapters = ADAPTERS.map((Adapter) => new Adapter(httpClient))\n\n    if (options.cache === '1') {\n      this.cache = cacheManager.caching({ store: 'memory' })\n    } else if (options.cache && options.cache !== '0') {\n      this.cache = cacheManager.caching({\n        store: redisStore,\n        url: options.cache,\n      })\n    }\n  }\n\n  _getAdapterForRequest(adapterName, type) {\n    let matchingAdapters = this.adapters\n\n    matchingAdapters = matchingAdapters.filter((adapter) => {\n      return adapterName === adapter.constructor.name\n    })\n\n    if (type) {\n      matchingAdapters = matchingAdapters.filter((adapter) => {\n        return adapter.constructor.SUPPORTED_TYPES.includes(type)\n      })\n    }\n\n    return matchingAdapters[0]\n  }\n\n  async _invokeAdapterMethod(adapter, method, request) {\n    console.log('adapter: ')\n    console.log(adapter)\n    console.log('method: ' + method)\n    console.log('request: ')\n    console.log(request)\n    let results = await adapter[method](request)\n    return results.map((result) => {\n      return normalizeResult(adapter, result)\n    })\n  }\n\n  // Aggregate method that dispatches requests to matching adapters\n  async _retrieveResource(resourceName, args) {\n    let { adapter, id } = parsePornId(args.id)\n    let request = {\n      query: { type: args.type, id },\n    }\n    if (!isNaN(args.extra.skip)) {\n      request.skip = parseInt(args.extra.skip, 10)\n    }\n    if (args.extra.search) {\n      request.query.search = args.extra.search\n    }\n    if (args.extra.genre) {\n      request.query.genre = args.extra.genre\n    }\n\n    let adapterImpl = this._getAdapterForRequest(adapter, args.type)\n    if (!adapterImpl) {\n      throw new Error('Couldn\\'t find suitable adapters for a request')\n    }\n    if (resourceName === 'catalog') {\n      return { metas: await this._invokeAdapterMethod(adapterImpl, 'find', request) }\n    } else if (resourceName === 'meta') {\n      return { meta: (await this._invokeAdapterMethod(adapterImpl, 'getItem', request))[0] }\n    } else if (resourceName === 'stream') {\n      return { streams: await this._invokeAdapterMethod(adapterImpl, 'getStreams', request) }\n    } else {\n      throw new Error(`Invalid resourceName: ${resourceName}`)\n    }\n  }\n\n  // This is a public wrapper around the private method\n  // that implements caching and result normalization\n  async invokeResource(resourceName, args) {\n    let invokeResource = async () => {\n      return this._retrieveResource(resourceName, args)\n    }\n\n    if (this.cache) {\n      // @TODO more for search\n      let cacheTtl = 300\n      let cacheKey = CACHE_PREFIX + JSON.stringify({ resourceName, args })\n      let cacheOptions = {\n        ttl: cacheTtl,\n      }\n      return this.cache.wrap(cacheKey, invokeResource, cacheOptions)\n    } else {\n      return invokeResource()\n    }\n  }\n}\n\n\nexport default PornClient\n"],"file":"PornClient.js"}