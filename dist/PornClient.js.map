{"version":3,"sources":["../src/PornClient.js"],"names":["ID","CACHE_PREFIX","ADAPTERS","RedTube","SpankWire","Chaturbate","CATALOGS","map","name","DISPLAY_NAME","SUPPORTED_TYPES","GENRES","type","id","makePornId","genres","extra","reduce","a","b","concat","adapter","parsePornId","pornId","split","pop","normalizeResult","item","newItem","constructor","PornClient","options","httpClient","HttpClient","adapters","Adapter","cache","cacheManager","caching","store","redisStore","url","_getAdapterForRequest","adapterName","matchingAdapters","filter","includes","_invokeAdapterMethod","method","request","results","result","_retrieveResource","resourceName","args","query","isNaN","skip","parseInt","search","genre","adapterImpl","Error","metas","limit","cacheMaxAge","meta","streams","invokeResource","cacheTtl","cacheKey","JSON","stringify","cacheOptions","ttl","wrap"],"mappings":"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","sourcesContent":["import cacheManager from 'cache-manager'\nimport redisStore from 'cache-manager-redis-store'\nimport HttpClient from './HttpClient'\nimport PornHub from './adapters/PornHub'\nimport RedTube from './adapters/RedTube'\nimport YouPorn from './adapters/YouPorn'\nimport SpankWire from './adapters/SpankWire'\nimport PornCom from './adapters/PornCom'\nimport Chaturbate from './adapters/Chaturbate'\n\n// EPorner has restricted video downloads to 30 per day per guest\n// import EPorner from './adapters/EPorner'\n\nconst ID = 'porn_id'\nconst CACHE_PREFIX = 'stremio-porn|'\n// Making multiple requests to multiple adapters for different types\n// and then aggregating them is a lot of work,\n// so we only support 1 adapter per request for now.\nconst ADAPTERS = [RedTube, SpankWire, Chaturbate]\nconst CATALOGS = ADAPTERS.map(({ name, DISPLAY_NAME, SUPPORTED_TYPES, GENRES }) => {\n  return SUPPORTED_TYPES.map((type) => ({\n    type,\n    id: makePornId(name, type, 'top'),\n    name: `Porn: ${DISPLAY_NAME}`,\n    genres: GENRES,\n    extra: [{ name: 'search' }, { name: 'genre' }],\n  }))\n}).reduce((a, b) => a.concat(b), [])\n\nfunction makePornId(adapter, type, id) {\n  return `${ID}:${adapter}-${type}-${id}`\n}\n\nfunction parsePornId(pornId) {\n  let [adapter, type, id] = pornId.split(':').pop().split('-')\n  return { adapter, type, id }\n}\n\nfunction normalizeResult(adapter, item) {\n  let newItem = { ...item }\n  if (item.id) {\n    newItem.id = makePornId(adapter.constructor.name, item.type, item.id)\n  }\n  return newItem\n}\n\nclass PornClient {\n  static ID = ID\n  static ADAPTERS = ADAPTERS\n  static CATALOGS = CATALOGS\n\n  constructor(options) {\n    let httpClient = new HttpClient(options)\n    this.adapters = ADAPTERS.map((Adapter) => new Adapter(httpClient))\n\n    if (options.cache === '1') {\n      this.cache = cacheManager.caching({ store: 'memory' })\n    } else if (options.cache && options.cache !== '0') {\n      this.cache = cacheManager.caching({\n        store: redisStore,\n        url: options.cache,\n      })\n    }\n  }\n\n  _getAdapterForRequest(adapterName, type) {\n    let matchingAdapters = this.adapters\n\n    matchingAdapters = matchingAdapters.filter((adapter) => {\n      return adapterName === adapter.constructor.name\n    })\n\n    if (type) {\n      matchingAdapters = matchingAdapters.filter((adapter) => {\n        return adapter.constructor.SUPPORTED_TYPES.includes(type)\n      })\n    }\n\n    return matchingAdapters[0]\n  }\n\n  async _invokeAdapterMethod(adapter, method, request) {\n    let results = await adapter[method](request)\n    return results.map((result) => {\n      return normalizeResult(adapter, result)\n    })\n  }\n\n  // Aggregate method that dispatches requests to matching adapters\n  async _retrieveResource(resourceName, args) {\n    let { adapter, id } = parsePornId(args.id)\n    let request = {\n      query: { type: args.type, id },\n    }\n    if (!isNaN(args.extra.skip)) {\n      request.skip = parseInt(args.extra.skip, 10)\n    }\n    if (args.extra.search) {\n      request.query.search = args.extra.search\n    }\n    if (args.extra.genre) {\n      request.query.genre = args.extra.genre\n    }\n\n    let adapterImpl = this._getAdapterForRequest(adapter, args.type)\n    if (!adapterImpl) {\n      throw new Error('Couldn\\'t find suitable adapters for a request')\n    }\n    if (resourceName === 'catalog') {\n      return { metas: await this._invokeAdapterMethod(adapterImpl, 'find', { limit: 100, ...request }), cacheMaxAge: 3600 }\n    } else if (resourceName === 'meta') {\n      return { meta: (await this._invokeAdapterMethod(adapterImpl, 'getItem', request))[0], cacheMaxAge: 300 }\n    } else if (resourceName === 'stream') {\n      return { streams: await this._invokeAdapterMethod(adapterImpl, 'getStreams', request), cacheMaxAge: 300 }\n    } else {\n      throw new Error(`Invalid resourceName: ${resourceName}`)\n    }\n  }\n\n  // This is a public wrapper around the private method\n  // that implements caching and result normalization\n  async invokeResource(resourceName, args) {\n    let invokeResource = async () => {\n      return this._retrieveResource(resourceName, args)\n    }\n\n    if (this.cache) {\n      let cacheTtl = resourceName == 'catalog' ? 3600 : 300\n      let cacheKey = CACHE_PREFIX + JSON.stringify({ resourceName, args })\n      let cacheOptions = {\n        ttl: cacheTtl,\n      }\n      return this.cache.wrap(cacheKey, invokeResource, cacheOptions)\n    } else {\n      return invokeResource()\n    }\n  }\n}\n\n\nexport default PornClient\n"],"file":"PornClient.js"}